# Data Model: VLA Integration

**Date**: 2025-12-06
**Feature**: Vision-Language-Action (VLA) Integration
**Purpose**: Define core data structures for the voice-to-action pipeline

## Overview

The VLA system uses six primary entities to represent the flow from voice input to robot execution:
1. **VoiceCommand** - Captured audio and transcription
2. **ParsedIntent** - Structured interpretation of command
3. **ActionPlan** - Sequence of robot actions
4. **RobotAction** - Individual executable step
5. **ExecutionState** - Runtime task status
6. **ExecutionLog** - Persistent audit trail

## Entity Definitions

### VoiceCommand

Represents a single voice utterance from the operator.

**Fields**:
| Field | Type | Description | Validation |
|-------|------|-------------|------------|
| `id` | UUID | Unique identifier | Auto-generated |
| `audio_buffer` | bytes | Raw audio data (WAV format) | Max 60 seconds |
| `transcribed_text` | str | Whisper output text | Non-empty string |
| `confidence` | float | Transcription confidence score | Range [0.0, 1.0] |
| `timestamp` | datetime | Capture time (UTC) | ISO 8601 format |
| `language` | str | Detected language code | Default: "en" |
| `sample_rate` | int | Audio sample rate (Hz) | 16000 or 44100 |

**State Transitions**: None (immutable after creation)

**Example**:
```python
VoiceCommand(
    id=UUID("a1b2c3..."),
    audio_buffer=b'\x00\x01...',
    transcribed_text="Pick up the red block",
    confidence=0.94,
    timestamp=datetime(2025, 12, 6, 14, 30, 0),
    language="en",
    sample_rate=16000
)
```

**Validation Rules**:
- `confidence < 0.7` → trigger retry request
- `transcribed_text.strip() == ""` → invalid command error

---

### ParsedIntent

Structured representation of command semantics extracted by LLM.

**Fields**:
| Field | Type | Description | Validation |
|-------|------|-------------|------------|
| `command_id` | UUID | Reference to VoiceCommand | Foreign key |
| `action_type` | ActionType (enum) | Primary action category | See ActionType enum |
| `target_objects` | List[ObjectReference] | Identified objects in command | 0-5 objects |
| `parameters` | Dict[str, Any] | Action-specific params | JSON-serializable |
| `ambiguities` | List[str] | Unclear aspects needing clarification | Empty if unambiguous |
| `requires_clarification` | bool | Whether to pause for user input | Derived from ambiguities |

**ActionType Enum**:
- `NAVIGATE` - Move to location
- `PICK` - Grasp object
- `PLACE` - Release object at location
- `INSPECT` - Observe object/area
- `MANIPULATE` - General arm movement
- `WAIT` - Pause for duration
- `STOP` - Emergency halt
- `UNKNOWN` - Could not classify

**ObjectReference Schema**:
```python
{
    "name": str,           # e.g., "red block"
    "type": str,           # e.g., "block", "cup"
    "color": Optional[str],
    "position": Optional[Point3D],  # If known from scene
    "confidence": float    # LLM certainty
}
```

**Parameters Examples**:
```python
# NAVIGATE command
{"target_pose": {"x": 2.0, "y": 1.5, "theta": 0.0}, "speed": "normal"}

# PICK command
{"object_id": "red_block_1", "approach_offset": {"z": 0.1}, "grasp_type": "top"}

# WAIT command
{"duration_seconds": 5.0}
```

**Example**:
```python
ParsedIntent(
    command_id=UUID("a1b2c3..."),
    action_type=ActionType.PICK,
    target_objects=[
        ObjectReference(name="red block", type="block", color="red", confidence=0.92)
    ],
    parameters={"grasp_type": "top", "approach_offset": {"z": 0.1}},
    ambiguities=[],
    requires_clarification=False
)
```

**Validation Rules**:
- If `action_type == UNKNOWN` → set `requires_clarification=True`
- If `target_objects` empty for PICK/PLACE → add ambiguity "No target object specified"
- If `parameters` missing required keys for action_type → validation error

---

### ActionPlan

Ordered sequence of atomic robot actions generated by cognitive planner.

**Fields**:
| Field | Type | Description | Validation |
|-------|------|-------------|------------|
| `plan_id` | UUID | Unique plan identifier | Auto-generated |
| `intent_id` | UUID | Reference to ParsedIntent | Foreign key |
| `steps` | List[RobotAction] | Ordered action sequence | 1-10 steps |
| `preconditions` | List[str] | Required initial state | Human-readable strings |
| `expected_outcomes` | List[str] | Predicted final state | Human-readable strings |
| `estimated_duration` | float | Total execution time (seconds) | Sum of step durations |
| `created_at` | datetime | Plan generation time | ISO 8601 |
| `validated` | bool | Passed safety checks | Must be True before execution |
| `validation_errors` | List[str] | Reasons if validation failed | Empty if validated=True |

**Example**:
```python
ActionPlan(
    plan_id=UUID("d4e5f6..."),
    intent_id=UUID("a1b2c3..."),
    steps=[
        RobotAction(action_type="NAVIGATE", target={"x": 1.0, "y": 0.5}),
        RobotAction(action_type="PICK", object_id="red_block_1"),
        RobotAction(action_type="NAVIGATE", target={"x": 2.0, "y": 1.0}),
        RobotAction(action_type="PLACE", placement_pose={"x": 2.0, "y": 1.0, "z": 0.8})
    ],
    preconditions=["Robot arm in home position", "Red block visible"],
    expected_outcomes=["Red block moved to target location"],
    estimated_duration=15.5,
    validated=True,
    validation_errors=[]
)
```

**Validation Rules**:
- `len(steps) == 0` → invalid plan error
- `validated == False` → cannot execute
- Step order must be topologically consistent (can't PLACE before PICK)

---

### RobotAction

Single atomic action executable by ROS action server.

**Fields**:
| Field | Type | Description | Validation |
|-------|------|-------------|------------|
| `action_id` | UUID | Unique action identifier | Auto-generated |
| `action_type` | ActionType | Type of action | Same enum as ParsedIntent |
| `ros_action_name` | str | ROS action server topic | e.g., "/pick_object" |
| `goal_message` | Dict[str, Any] | ROS action goal payload | Matches action interface |
| `constraints` | ActionConstraints | Safety/performance limits | See ActionConstraints |
| `timeout` | float | Max execution time (seconds) | Default: 30.0 |
| `retry_on_failure` | bool | Whether to retry once | Default: False |

**ActionConstraints Schema**:
```python
{
    "max_force": float,           # Newtons
    "max_velocity": float,        # m/s or rad/s
    "collision_check": bool,      # Enable collision detection
    "joint_limits_check": bool    # Verify within [q_min, q_max]
}
```

**Example**:
```python
RobotAction(
    action_id=UUID("g7h8i9..."),
    action_type=ActionType.PICK,
    ros_action_name="/pick_object",
    goal_message={
        "object_id": "red_block_1",
        "approach_offset": {"x": 0.0, "y": 0.0, "z": 0.1},
        "grasp_type": "top"
    },
    constraints={
        "max_force": 50.0,
        "max_velocity": 0.5,
        "collision_check": True,
        "joint_limits_check": True
    },
    timeout=10.0,
    retry_on_failure=False
)
```

**Validation Rules**:
- `ros_action_name` must exist in ROS graph
- `goal_message` schema must match ROS action interface definition
- `timeout > 0` and `< 300` seconds

---

### ExecutionState

Real-time state of plan execution.

**Fields**:
| Field | Type | Description | Validation |
|-------|------|-------------|------------|
| `plan_id` | UUID | Reference to ActionPlan | Foreign key |
| `status` | ExecutionStatus (enum) | Current execution phase | See enum below |
| `current_step_index` | int | Index in plan.steps | Range [0, len(steps)-1] |
| `completed_steps` | List[UUID] | action_ids of finished steps | Append-only |
| `current_action_id` | Optional[UUID] | Active action | None if idle |
| `progress_percent` | float | Overall completion | Range [0.0, 100.0] |
| `errors` | List[ExecutionError] | Encountered errors | See ExecutionError |
| `started_at` | datetime | Execution start time | ISO 8601 |
| `completed_at` | Optional[datetime] | Execution end time | None if in progress |

**ExecutionStatus Enum**:
- `IDLE` - Not started
- `RUNNING` - Actively executing
- `PAUSED` - User pause requested
- `COMPLETED` - All steps succeeded
- `FAILED` - Unrecoverable error
- `CANCELLED` - User cancellation

**ExecutionError Schema**:
```python
{
    "timestamp": datetime,
    "step_index": int,
    "error_code": str,      # e.g., "COLLISION_DETECTED"
    "message": str,         # Human-readable description
    "recoverable": bool     # Whether retry possible
}
```

**Example**:
```python
ExecutionState(
    plan_id=UUID("d4e5f6..."),
    status=ExecutionStatus.RUNNING,
    current_step_index=2,
    completed_steps=[UUID("g7h8i9..."), UUID("j1k2l3...")],
    current_action_id=UUID("m4n5o6..."),
    progress_percent=66.7,
    errors=[],
    started_at=datetime(2025, 12, 6, 14, 30, 5),
    completed_at=None
)
```

**State Transition Rules**:
```
IDLE → RUNNING: Plan execution starts
RUNNING → PAUSED: User pause command
PAUSED → RUNNING: User resume command
RUNNING → COMPLETED: All steps finish successfully
RUNNING → FAILED: Unrecoverable error
RUNNING/PAUSED → CANCELLED: User cancel command
```

---

### ExecutionLog

Persistent audit trail for debugging and analysis.

**Fields**:
| Field | Type | Description | Validation |
|-------|------|-------------|------------|
| `log_id` | UUID | Unique log identifier | Auto-generated |
| `plan_id` | UUID | Reference to ActionPlan | Foreign key |
| `voice_command_text` | str | Original transcribed command | Copy from VoiceCommand |
| `parsed_intent_summary` | str | Human-readable intent | e.g., "Pick red block" |
| `plan_steps_summary` | List[str] | Action sequence descriptions | e.g., ["Navigate to (1,0)", "Pick red_block_1"] |
| `execution_trace` | List[TraceEntry] | Timestamped event log | See TraceEntry |
| `final_status` | ExecutionStatus | End state | COMPLETED/FAILED/CANCELLED |
| `total_duration` | float | Elapsed time (seconds) | completed_at - started_at |
| `logged_at` | datetime | Log write time | ISO 8601 |

**TraceEntry Schema**:
```python
{
    "timestamp": datetime,
    "event_type": str,      # "ACTION_START", "ACTION_COMPLETE", "ERROR", "FEEDBACK"
    "step_index": int,
    "message": str,
    "data": Optional[dict]  # Additional context
}
```

**Example**:
```python
ExecutionLog(
    log_id=UUID("p7q8r9..."),
    plan_id=UUID("d4e5f6..."),
    voice_command_text="Pick up the red block",
    parsed_intent_summary="Pick object: red block",
    plan_steps_summary=[
        "Navigate to (1.0, 0.5)",
        "Pick object: red_block_1",
        "Navigate to (2.0, 1.0)",
        "Place at (2.0, 1.0, 0.8)"
    ],
    execution_trace=[
        {"timestamp": ..., "event_type": "ACTION_START", "step_index": 0, "message": "Starting navigation"},
        {"timestamp": ..., "event_type": "FEEDBACK", "step_index": 0, "message": "50% complete"},
        {"timestamp": ..., "event_type": "ACTION_COMPLETE", "step_index": 0, "message": "Navigation finished"}
    ],
    final_status=ExecutionStatus.COMPLETED,
    total_duration=14.2,
    logged_at=datetime(2025, 12, 6, 14, 30, 20)
)
```

**Persistence**: Logs written to JSON files in `logs/executions/YYYY-MM-DD/{plan_id}.json`

---

## Relationships

```
VoiceCommand (1) ──< ParsedIntent (1) ──< ActionPlan (1) ──< ExecutionState (1)
                                              │                       │
                                              └──< ExecutionLog (1) ──┘
                                              │
                                              └──> RobotAction (N)
```

---

## Validation Summary

| Entity | Key Validations |
|--------|-----------------|
| VoiceCommand | confidence ≥ 0.7, transcribed_text non-empty |
| ParsedIntent | action_type != UNKNOWN unless requires_clarification |
| ActionPlan | validated=True, steps non-empty, topological consistency |
| RobotAction | ROS action exists, goal_message matches interface |
| ExecutionState | status transitions follow state machine rules |
| ExecutionLog | final_status in {COMPLETED, FAILED, CANCELLED} |

---

## Next Steps

Proceed to defining ROS 2 action interface contracts in `contracts/` directory.